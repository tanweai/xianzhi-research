# 二进制安全研究方法论

## 元思考框架

### 核心思维范式

```
漏洞本质 = 边界失控 + 状态不一致 + 信任假设违背
```

**三层抽象模型**：

| 层次 | 关注点 | 典型问题 |
|------|--------|----------|
| **数据层** | 内存边界、类型安全 | 溢出、类型混淆、整数溢出 |
| **控制流层** | 执行路径、返回地址 | ROP、JOP、CFI绕过 |
| **语义层** | 程序逻辑、状态机 | UAF、条件竞争、逻辑漏洞 |

### 利用思维递进模型

```
信息泄露 → 原语构造 → 控制流劫持 → 任意代码执行
   ↓           ↓           ↓            ↓
 地址获取    写原语      RIP控制     shellcode/ROP
```

**核心洞察**：每一步都是为下一步创造条件，利用链的本质是**原语的组合与放大**。

---

## 漏洞模式识别

### 栈溢出

**识别checklist**：
1. 危险函数: gets(), strcpy(), sprintf(), scanf("%s"), read()无边界
2. 栈布局分析: buffer到ebp/rbp的偏移 + 指针大小 = 返回地址偏移
3. 保护检查: checksec确认NX/Canary/PIE/ASLR状态

**偏移计算公式（32位）**：
```
offset = buffer_size + saved_ebp(4) = distance_to_ret
```

### 堆漏洞

| 类型 | 识别特征 | 利用方向 |
|------|----------|----------|
| **UAF** | free后指针未置空 | tcache poisoning |
| **Double Free** | 同一chunk释放两次 | 链表污染 |
| **Heap Overflow** | 写入超过chunk边界 | 修改相邻chunk元数据 |
| **Off-by-one** | 边界差一字节 | chunk overlapping |

### 格式化字符串

**漏洞代码**：`printf(user_input);`
**正常代码**：`printf("%s", user_input);`

**利用能力**：
- `%p`/`%x`：泄露栈上数据
- `%s`：泄露任意地址内容
- `%n`：向任意地址写入数据

---

## 保护绕过矩阵

| 保护机制 | 防护目标 | 绕过策略 |
|----------|----------|----------|
| **NX/DEP** | 禁止栈执行 | ROP/JOP/ret2libc |
| **ASLR** | 地址随机化 | 格式化字符串泄露、UAF泄露 |
| **Canary** | 栈溢出检测 | 泄露或劫持`__stack_chk_fail` |
| **PIE** | 代码段随机化 | 部分覆写、信息泄露 |
| **RELRO** | GOT表保护 | `__malloc_hook`、`__free_hook` |
| **Safe-linking** (2.32+) | tcache指针加密 | 泄露heap地址解密 |

### ASLR绕过的信息泄露链

```
泄露libc地址的典型方法:
1. 格式化字符串: %p泄露栈上的libc地址
2. GOT泄露: 调用puts(puts_got)泄露puts真实地址
3. UAF泄露: free后的chunk进入unsorted bin，fd/bk指向main_arena
4. stdout泄露: 利用_IO_2_1_stdout_结构体
```

---

## ROP技术谱系

```
┌─────────────────────────────────────────────────────────────┐
│                      ROP技术谱系                            │
├─────────────────────────────────────────────────────────────┤
│  ret2text ─────► 程序内有后门函数，直接跳转                 │
│       ↓                                                     │
│  ret2libc ─────► 利用libc中的system("/bin/sh")             │
│       ↓                                                     │
│  ret2syscall ──► 静态编译，直接构造系统调用                 │
│       ↓                                                     │
│  ret2csu ──────► gadget不足时，利用__libc_csu_init          │
│       ↓                                                     │
│  SROP ─────────► 利用sigreturn控制所有寄存器                │
│       ↓                                                     │
│  ret2dlresolve ► 无libc泄露，伪造延迟绑定结构               │
└─────────────────────────────────────────────────────────────┘
```

### ret2libc标准流程（64位）

```python
# 第一阶段: 泄露libc地址
payload1 = padding + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)

# 第二阶段: 计算并调用system
libc_base = leaked_puts - libc.symbols['puts']
system = libc_base + libc.symbols['system']
binsh = libc_base + next(libc.search(b'/bin/sh'))
payload2 = padding + p64(pop_rdi) + p64(binsh) + p64(system)
```

---

## House of系列

| 技术名称 | 核心原理 | 适用版本 |
|----------|----------|----------|
| **House of Force** | 控制top chunk size | < 2.29 |
| **House of Orange** | 无free获得unsorted bin | < 2.24 |
| **House of Botcake** | tcache与unsorted bin重叠 | 2.27-2.31 |
| **House of Apple2** | _IO_wfile_overflow | 2.24+ |
| **House of Kiwi** | __malloc_assert触发 | 2.32+ |

### tcache poisoning

```
目标: 让tcache链表包含目标地址，使malloc返回任意地址

glibc 2.32+需要解密:
encrypted_ptr = (heap_addr >> 12) ^ target_addr
```

---

## IO_FILE利用

### 演进思路

```
glibc 2.24之前: 直接伪造vtable
glibc 2.24-2.35: 利用_IO_str_overflow等合法函数
glibc 2.35+: _wide_data利用 (house_of_apple2)
```

### House of Apple2核心

**绕过思路**：vtable检查只检查`_IO_FILE`的vtable，不检查`_wide_data`的vtable

**利用链**：
```
_IO_flush_all_lockp → _IO_wfile_overflow → _IO_wdoallocbuf → WDOALLOCATE
```

---

## 调试核心命令

```bash
# 基础检查
checksec ./binary

# pwndbg扩展
heap              # 查看堆布局
bins              # 查看所有bin
tcache            # 查看tcache
vmmap             # 查看内存映射

# ROPgadget
ROPgadget --binary ./binary --only "pop|ret"
```
