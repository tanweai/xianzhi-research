# 逆向分析安全研究方法论

## 元思考框架

### 逆向分析的本质

**逆向分析 = 信息熵降低过程**：将未知二进制行为映射到已知模式库

| 维度 | 核心问题 |
|------|----------|
| **What** | 程序做了什么？ |
| **Why** | 为什么这样设计？ |
| **How** | 如何实现的？ |
| **Who** | 谁是目标/作者？ |

### 分析策略决策树

```
样本获取 → 初步分类 → 策略选择 → 深入分析 → 行为提取 → 规则编写
              ↓
         ┌────────────┐
         │ 静态优先？ │
         │ 动态优先？ │
         │ 混合分析？ │
         └────────────┘
```

---

## 样本分类决策

### 文件头魔数识别

| 魔数 | 文件类型 |
|------|----------|
| `MZ` (4D 5A) | Windows PE |
| `ELF` (7F 45 4C 46) | Linux ELF |
| `PK` (50 4B) | ZIP/APK/DOCX |
| `%PDF` | PDF |
| `d8 ff` | JPEG |

### 查壳与编译器识别

| 工具 | 用途 |
|------|------|
| DIE (Detect It Easy) | 壳识别、编译器识别 |
| PEiD | 经典PE查壳 |
| ExeInfo PE | PE信息分析 |
| PEID signatures | 自定义签名 |

### 恶意行为模式速查

| 行为类别 | 典型API/特征 |
|----------|--------------|
| **进程注入** | VirtualAllocEx, WriteProcessMemory, CreateRemoteThread |
| **持久化** | RegSetValueEx, CreateService, 计划任务 |
| **信息窃取** | 剪贴板、键盘钩子、屏幕截图 |
| **网络通信** | socket, WinHTTP, WinINet |
| **反调试** | IsDebuggerPresent, NtQueryInformationProcess |

---

## 分析策略选择

### 静态分析思维框架

```
1. 字符串提取 → 快速定位关键功能
2. 导入表分析 → 判断程序能力
3. 函数识别 → 定位关键代码
4. 控制流分析 → 理解程序逻辑
5. 数据流分析 → 追踪敏感数据
```

### 动态调试策略

| 文件类型 | 调试方法 | 注意事项 |
|----------|----------|----------|
| **EXE** | 附加进程 | 绕过TLS回调反调试 |
| **ELF** | linux_server远程调试 | 配置调试选项 |
| **APK** | 添加debuggable属性 | 重打包签名 |

### 工具链组合

| 场景 | 推荐组合 |
|------|----------|
| PE分析 | IDA Pro + x64dbg + Process Monitor |
| ELF分析 | IDA Pro + GDB + strace |
| APK分析 | jadx + Frida + adb |
| .NET分析 | dnSpy + ILSpy |
| Python打包 | pyinstxtractor + uncompyle6 |

---

## 反混淆思维

### 常见混淆技术与对抗

| 混淆类型 | 对抗方法 |
|----------|----------|
| **字符串加密** | 动态调试提取、模拟执行 |
| **控制流平坦化** | 符号执行、模式识别 |
| **不透明谓词** | 数据流分析、常量传播 |
| **虚拟机保护** | opcode还原、z3求解 |

### VM类保护分析方法

**三条路径**：

1. **opcode还原（传统）**
   - 分析VM入口、dispatcher、handler
   - 逐个识别虚拟指令含义
   - 还原原始逻辑

2. **z3约束求解（数学）**
   - 将VM执行建模为约束
   - 使用SMT求解器求解
   - 适合简单变换

3. **插桩爆破（侧信道）**
   - Unicorn模拟执行
   - 逐字符爆破输入
   - 根据执行路径差异判断

### OLLVM反混淆范式

```
Triton符号执行 → AST提取 → Z3/AI化简 → 算法还原
```

---

## 沙箱绕过六维度

恶意软件常用的沙箱检测技术：

| 维度 | 检测方法 | 绕过特征 |
|------|----------|----------|
| **用户名** | 检测沙箱常用用户名 | "sandbox", "malware", "virus" |
| **调试器** | IsDebuggerPresent, PEB | BeingDebugged标志 |
| **VM痕迹** | 注册表、进程、服务 | VMware Tools, VBox Guest |
| **系统资源** | CPU核心数、内存、磁盘 | 资源过少说明是虚拟环境 |
| **启动时间** | 系统运行时间检测 | 沙箱通常刚启动 |
| **父进程** | 检测父进程合法性 | explorer.exe vs 分析工具 |

---

## 脱壳方法论

### 通用脱壳方法

| 方法 | 原理 | 适用场景 |
|------|------|----------|
| **ESP定律** | 栈平衡定位OEP | 压缩壳 |
| **内存断点** | 代码段执行断点 | 大多数壳 |
| **API断点** | GetProcAddress等 | IAT恢复 |
| **单步跟踪** | F7/F8逐步执行 | 简单壳 |
| **硬件断点** | DR寄存器断点 | 反软件断点的壳 |
| **脚本脱壳** | OD/x64dbg脚本 | 已知壳 |
| **Dump+修复** | 内存Dump+IAT修复 | 通用 |

---

## 免杀技术层次

```
指令级 → 结构级 → 数据级 → 噪音注入
   ↓         ↓         ↓         ↓
等价替换  控制流平坦化  多算法加密  垃圾代码
```

| 层次 | 技术 | 效果 |
|------|------|------|
| **指令级** | 等价指令替换、寄存器轮换 | 改变特征码 |
| **结构级** | 控制流平坦化、函数拆分 | 改变代码结构 |
| **数据级** | 字符串加密、资源加密 | 隐藏敏感数据 |
| **噪音注入** | 垃圾代码、花指令 | 干扰分析 |

---

## C2通信分析

### 通信协议识别

| 协议类型 | 识别特征 |
|----------|----------|
| **HTTP(S)** | 标准端口、HTTP头 |
| **DNS隧道** | 异常DNS查询频率、长子域名 |
| **ICMP隧道** | 异常ICMP数据长度 |
| **自定义TCP/UDP** | 非标准端口、自定义包结构 |

### 加密通信分析

1. **定位加密函数**：断点CryptEncrypt、SSL_write等
2. **提取密钥**：内存搜索、动态调试
3. **协议逆向**：分析包结构、字段含义

---

## 核心洞察

1. **逆向是信息熵降低**：将未知映射到已知模式库
2. **VM对抗三路径**：opcode还原、z3约束、插桩爆破各有适用场景
3. **动态调试精髓**：EXE附加绕TLS，ELF远程调试，APK加debuggable
4. **AI辅助逆向**：Triton + Z3 + AI 是 OLLVM 反混淆现代范式
5. **沙箱六维度**：恶意软件的标配检测，需逐一识别分析
