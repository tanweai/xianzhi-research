# Fuzzing/漏洞发现方法论

## 元思考框架

### 核心认知模型

**漏洞发现 = 攻击面识别 + 输入控制 + 状态异常触发 + 可利用性评估**

| 阶段 | 核心问题 | 方法论要点 |
|------|---------|-----------|
| 目标选择 | 哪里最可能出问题？ | 解析器、协议处理、格式转换、边界条件 |
| 输入构造 | 如何触发异常状态？ | 覆盖率引导、字典优化、结构化变异 |
| 崩溃分析 | 这个crash有价值吗？ | 从crash到可控、从DoS到RCE的路径 |
| 利用构造 | 如何将异常转化为攻击？ | 堆布局、内存结构控制、执行流劫持 |

### 关键思维转变

**从CTF-Pwn到实战的认知跃迁**：
- CTF提供明确的增删改查接口，实战需要**逆向分析程序中的每一个堆操作**
- 实战漏洞往往**只能触发一次**，需要精确的堆风水和状态控制
- 需要了解整个Linux机制，筛选出可控的堆操作来提升漏洞可用性

---

## 目标选择策略

### 高价值目标特征矩阵

| 目标类型 | 价值评估 | 典型场景 |
|---------|---------|---------|
| **解析器类** | ★★★★★ | JSON/XML/YAML/Markdown解析 |
| **协议处理** | ★★★★★ | SSL/TLS、HTTP、DNS |
| **格式处理** | ★★★★☆ | 图片/PDF/视频编解码 |
| **命令行工具** | ★★★★☆ | sudo、系统工具 |
| **库函数API** | ★★★☆☆ | 标准库、第三方库 |

### 目标选择决策流程

```
1. 识别输入入口点
   ├── 文件解析 (stdin/file)
   ├── 网络协议 (socket)
   ├── 命令行参数 (argv)
   └── 环境变量 (envp)

2. 评估复杂度与攻击面
   ├── 状态机复杂度 → 越复杂越容易出错
   ├── 边界条件数量 → 边界条件是漏洞温床
   └── 历史漏洞记录 → 同类问题往往重复出现

3. 确认可测试性
   ├── 源码可用性 → 插桩编译可行性
   ├── 反馈机制 → 覆盖率收集能力
   └── 执行效率 → 单次执行时间 < 1秒
```

---

## 输入构造与变异

### 覆盖率驱动机制

**AFL++核心流程**：
```
源码插桩 → 语料库变异 → 执行收集覆盖率 → 路径反馈优化
```

### 变异策略

| 变异类型 | 方法 | 适用场景 |
|----------|------|----------|
| **位翻转** | 随机翻转比特位 | 通用 |
| **字节替换** | 替换为特殊值 | 边界测试 |
| **块操作** | 插入/删除/复制 | 结构变异 |
| **字典变异** | 使用关键词字典 | 协议/格式 |
| **语法变异** | 基于语法树变异 | 结构化输入 |

### 特殊场景处理

**命令行程序Fuzzing（sudo案例）**：
```
问题：密码验证、参数控制、程序名切换

解决方案：
1. Patch密码验证函数，返回固定值
2. 使用AFL++的argv-fuzz-inl.h从stdin构建argv
3. 使用AFL_INIT_SET0("sudoedit")控制程序名
```

---

## 崩溃分析

### 从crash到可利用

```
crash分类
    │
    ├─── 空指针解引用 → 通常不可利用
    │
    ├─── 栈溢出 → 控制返回地址 → ROP
    │
    ├─── 堆溢出 → 破坏堆元数据 → 任意写
    │
    ├─── UAF → 控制freed内存 → 代码执行
    │
    └─── 整数溢出 → 导致其他内存错误
```

### ASAN辅助

```bash
# 编译时启用
gcc -fsanitize=address -g target.c

# 运行时环境变量
ASAN_OPTIONS=detect_leaks=0:abort_on_error=1
```

---

## CVE复现思维

### 1day分析流程

```
1. 补丁分析
   └─ 对比补丁前后的代码差异
   └─ 定位漏洞触发点

2. 环境搭建
   └─ 获取漏洞版本
   └─ 配置调试环境

3. 触发验证
   └─ 构造触发条件
   └─ 验证漏洞存在

4. 利用开发
   └─ 分析可利用性
   └─ 编写exploit
```

### 补丁分析技巧

- **关注边界检查**：新增的长度/范围检查
- **关注初始化**：新增的变量初始化
- **关注释放逻辑**：新增的内存释放
- **关注权限检查**：新增的权限验证

---

## Fuzzing工具链

| 工具 | 特点 | 适用场景 |
|------|------|----------|
| **AFL++** | 覆盖率引导、社区活跃 | 通用Fuzzing |
| **libFuzzer** | LLVM集成、内存高效 | 库函数 |
| **honggfuzz** | 多线程、硬件支持 | 多核环境 |
| **Peach** | 协议建模、状态机 | 网络协议 |
| **Boofuzz** | Python编写、易扩展 | 网络协议 |

---

## 核心洞察

1. **目标选择是关键**：解析器 > 协议处理 > 命令行工具
2. **状态机复杂度**：越复杂越容易出错，边界条件是漏洞温床
3. **覆盖率驱动**：AFL++ 插桩→变异→反馈→优化 是核心循环
4. **CTF到实战**：实战漏洞往往只能触发一次，需精确堆风水
5. **历史漏洞规律**：同类问题往往重复出现，关注历史CVE模式
